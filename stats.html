<body>
    <div class="container">
        <div class="header">
            <h1>QUAY 1 INTERNATIONAL REALTY</h1>
        </div>
        
        <div class="nav-bar">
            <a href="index.html">Dashboard</a>
            <a href="stats.html">Stats</a>
            <a href="import.html">Import Data</a>
            <button id="refreshButton" style="padding: 10px 20px; border: 2px solid #98C5ED; border-radius: 10px; background: white; color: #3D5BA6; font-weight: 500; cursor: pointer;"><i class="fas fa-sync-alt"></i> Refresh Data</button>
        </div>

        <!-- Modal for entering credentials -->
        <div id="refreshModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center;">
            <div style="background: white; padding: 20px; border-radius: 10px; max-width: 400px; width: 90%;">
                <h3 style="color: #3D5BA6; margin-bottom: 15px;">Enter Dialfire Credentials</h3>
                <input type="text" id="campaignIdInput" placeholder="Campaign ID (e.g., N4UMU8GPQKZMRM93)" style="width: 100%; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #98C5ED;">
                <input type="text" id="campaignTokenInput" placeholder="Campaign Token" style="width: 100%; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #98C5ED;">
                <button id="submitRefresh" style="padding: 10px 20px; background: #3D5BA6; color: white; border: none; border-radius: 10px; cursor: pointer;">Fetch</button>
                <button id="cancelRefresh" style="padding: 10px 20px; background: #D20A03; color: white; border: none; border-radius: 10px; margin-left: 10px;">Cancel</button>
            </div>
        </div>

        <div class="error" id="errorMessage"></div>
        <div class="loading" id="loading"><i class="fas fa-spinner fa-spin"></i> Fetching from Dialfire...</div>

        <div class="filters" id="filters" style="display: none;">
            <label>
                <strong>Month:</strong>
                <select id="monthFilter">
                    <option value="all">All Months</option>
                </select>
            </label>
            <label>
                <strong>Caller:</strong>
                <select id="callerFilter">
                    <option value="all">All Callers</option>
                </select>
            </label>
        </div>

        <table id="statsTable" style="display: none;">
            <thead>
                <tr>
                    <th onclick="sortTable('caller')">Caller <i class="fas fa-sort"></i></th>
                    <th onclick="sortTable('period')">Month <i class="fas fa-sort"></i></th>
                    <th onclick="sortTable('calls')">Total Calls <i class="fas fa-sort"></i></th>
                    <th onclick="sortTable('success')">Successful Calls <i class="fas fa-sort"></i></th>
                    <th onclick="sortTable('declines')">Declined Calls <i class="fas fa-sort"></i></th>
                    <th onclick="sortTable('rate')">Success Rate (%) <i class="fas fa-sort"></i></th>
                </tr>
            </thead>
            <tbody id="statsBody"></tbody>
        </table>
    </div>

    <script>
        let processedData = JSON.parse(localStorage.getItem('callAnalyticsData')) || {};
        let importedHashes = new Set(JSON.parse(localStorage.getItem('importedHashes')) || []);
        let sortColumn = 'caller';
        let sortDirection = 'asc';

        const errorDiv = document.getElementById('errorMessage');
        const loading = document.getElementById('loading');
        const monthFilterSelect = document.getElementById('monthFilter');
        const callerFilterSelect = document.getElementById('callerFilter');
        const statsTable = document.getElementById('statsTable');
        const statsBody = document.getElementById('statsBody');
        const refreshButton = document.getElementById('refreshButton');
        const refreshModal = document.getElementById('refreshModal');
        const campaignIdInput = document.getElementById('campaignIdInput');
        const campaignTokenInput = document.getElementById('campaignTokenInput');
        const submitRefresh = document.getElementById('submitRefresh');
        const cancelRefresh = document.getElementById('cancelRefresh');

        monthFilterSelect.addEventListener('change', updateStatsTable);
        callerFilterSelect.addEventListener('change', updateStatsTable);
        refreshButton.addEventListener('click', () => { refreshModal.style.display = 'flex'; });
        cancelRefresh.addEventListener('click', () => { refreshModal.style.display = 'none'; });
        submitRefresh.addEventListener('click', fetchDialfireData);

        async function fetchDialfireData() {
            const campaignId = campaignIdInput.value.trim();
            const token = campaignTokenInput.value.trim();

            if (!campaignId || !token) {
                showError('Please enter campaign ID and token.');
                refreshModal.style.display = 'none';
                return;
            }

            showLoading(true);
            hideError();
            refreshModal.style.display = 'none';

            try {
                const baseUrl = 'https://app.dialfire.com'; // Update if tenant-specific (e.g., 'https://3f88c548.app.dialfire.com')
                let allData = [];
                let page = 1;
                let hasMore = true;

                while (hasMore) {
                    const url = `${baseUrl}/api/campaigns/${campaignId}/connections?page=${page}&per_page=100&since=2025-10-01`;
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API error ${response.status}: ${errorText}`);
                    }

                    const data = await response.json();
                    const items = data.items || data;
                    allData = allData.concat(items);
                    hasMore = items.length === 100;
                    page++;
                    if (page > 10) break; // Safety limit
                }

                console.log('Fetched connections:', allData); // Inspect in DevTools
                processData(allData);
                showLoading(false);
            } catch (error) {
                console.error('Fetch error:', error);
                showError(`Failed to fetch: ${error.message}. Check ID/token.`);
                showLoading(false);
            }
        }

        function generateHash(str, date) {
            let hash = 0;
            const combined = `${str}${date || ''}`;
            for (let i = 0; i < combined.length; i++) {
                hash = ((hash << 5) - hash) + combined.charCodeAt(i);
                hash |= 0;
            }
            return hash.toString();
        }

        function processData(apiData) {
            if (!apiData || apiData.length === 0) {
                showError('No connections found. Check campaign ID or date range.');
                return;
            }

            let totalProcessed = 0;
            let errorCount = 0;
            let duplicatesSkipped = 0;

            apiData.forEach((row, index) => {
                let callNotes = (row.comment || row.agent_notes || row.status_detail || '').toString();
                if (row.status_detail && !callNotes.includes(row.status_detail)) {
                    callNotes += ` Dialfire call result: ${row.status_detail}/$none`;
                }
                const activityDate = row.created_at || row.connected_at || row.updated_at;
                const activityDateStr = activityDate ? new Date(activityDate).toISOString().split('T')[0] : '';

                if (!callNotes) {
                    console.warn(`Row ${index + 1}: Empty notes, skipping.`);
                    return;
                }

                const rowHash = generateHash(callNotes, activityDateStr);
                if (importedHashes.has(rowHash)) {
                    console.log(`Row ${index + 1}: Duplicate, skipping.`);
                    duplicatesSkipped++;
                    return;
                }

                try {
                    let caller = '';
                    const callerMatch = callNotes.match(/Call user:\s*([^@]+)@clienthub/i);
                    if (callerMatch) {
                        caller = callerMatch[1].trim();
                    } else if (row.agent_name || row.user_name) {
                        caller = (row.agent_name || row.user_name).trim();
                        console.log(`Row ${index + 1}: Fallback caller: ${caller}`);
                    } else {
                        console.warn(`Row ${index + 1}: No caller in ${callNotes}`);
                        return;
                    }

                    const statusDetail = (row.status_detail || '').toLowerCase();
                    let result = null;
                    if (['success', 'connected', 'completed', 'sale_made', 'appointment_set'].some(s => statusDetail.includes(s))) {
                        result = 'success';
                    } else if (['declined', 'refused', 'no_interest', 'busy', 'no_answer'].some(s => statusDetail.includes(s))) {
                        result = 'declined';
                    }
                    const notesMatch = callNotes.match(/Dialfire call result:\s*(success|declined)\/\$none/i);
                    if (notesMatch && !result) {
                        result = notesMatch[1].toLowerCase();
                    }

                    if (!processedData[caller]) {
                        processedData[caller] = {};
                    }

                    const period = activityDateStr || 'Unknown';
                    if (!processedData[caller][period]) {
                        processedData[caller][period] = {
                            calls: 0,
                            success: 0,
                            declines: 0
                        };
                    }

                    processedData[caller][period].calls += 1;
                    if (result === 'success') {
                        processedData[caller][period].success += 1;
                    } else if (result === 'declined') {
                        processedData[caller][period].declines += 1;
                    }

                    importedHashes.add(rowHash);
                    totalProcessed++;
                } catch (error) {
                    errorCount++;
                    console.warn(`Error processing row ${index + 1}:`, error);
                }
            });

            localStorage.setItem('callAnalyticsData', JSON.stringify(processedData));
            localStorage.setItem('importedHashes', JSON.stringify(Array.from(importedHashes)));

            console.log('Processed:', { totalProcessed, errorCount, duplicatesSkipped, sampleData: processedData });

            if (totalProcessed === 0) {
                showError(`No new data. Errors: ${errorCount}, Duplicates: ${duplicatesSkipped}. Check console.`);
                return;
            }

            updateFilters();
            updateStatsTable();
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function showLoading(show) {
            loading.style.display = show ? 'block' : 'none';
        }

        function hideError() {
            errorDiv.style.display = 'none';
        }

        function updateFilters() {
            const allCallers = new Set();
            const allPeriods = new Set();
            Object.entries(processedData).forEach(([caller, periods]) => {
                allCallers.add(caller);
                Object.keys(periods).forEach(period => allPeriods.add(period));
            });
            const sortedCallers = Array.from(allCallers).sort();
            const sortedPeriods = Array.from(allPeriods).sort((a, b) => {
                const dateA = a === 'Unknown' ? new Date(0) : new Date(a);
                const dateB = b === 'Unknown' ? new Date(0) : new Date(b);
                return dateA - dateB;
            });

            callerFilterSelect.innerHTML = '<option value="all">All Callers</option>';
            sortedCallers.forEach(caller => {
                const option = document.createElement('option');
                option.value = caller;
                option.textContent = caller;
                callerFilterSelect.appendChild(option);
            });

            monthFilterSelect.innerHTML = '<option value="all">All Months</option>';
            sortedPeriods.forEach(period => {
                const option = document.createElement('option');
                option.value = period;
                option.textContent = period;
                monthFilterSelect.appendChild(option);
            });
        }

        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            updateStatsTable();
        }

        function updateStatsTable() {
            const callerFilter = callerFilterSelect.value;
            const selectedMonth = monthFilterSelect.value;

            let filteredData = processedData;
            if (callerFilter !== 'all') {
                filteredData = { [callerFilter]: processedData[callerFilter] || {} };
            }

            let monthFilteredData = {};
            Object.entries(filteredData).forEach(([caller, periods]) => {
                monthFilteredData[caller] = {};
                if (selectedMonth === 'all') {
                    monthFilteredData[caller] = periods;
                } else if (periods[selectedMonth]) {
                    monthFilteredData[caller][selectedMonth] = periods[selectedMonth];
                }
            });

            const rows = [];
            Object.entries(monthFilteredData).forEach(([caller, periods]) => {
                Object.entries(periods).forEach(([period, stats]) => {
                    const successRate = stats.calls > 0 ? ((stats.success / stats.calls) * 100).toFixed(1) : 0;
                    rows.push({ caller, period, ...stats, rate: successRate });
                });
            });

            if (rows.length === 0) {
                showError('No data available for the selected filters.');
                statsTable.style.display = 'none';
                return;
            }

            rows.sort((a, b) => {
                let valueA = a[sortColumn];
                let valueB = b[sortColumn];
                if (sortColumn === 'caller') {
                    valueA = valueA.toLowerCase();
                    valueB = valueB.toLowerCase();
                } else if (sortColumn === 'period') {
                    valueA = a.period === 'Unknown' ? new Date(0) : new Date(a.period);
                    valueB = b.period === 'Unknown' ? new Date(0) : new Date(b.period);
                } else {
                    valueA = Number(valueA);
                    valueB = Number(valueB);
                }
                if (sortDirection === 'asc') {
                    return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
                } else {
                    return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
                }
            });

            statsBody.innerHTML = rows.map(row => `
                <tr>
                    <td>${row.caller}</td>
                    <td>${row.period}</td>
                    <td>${row.calls}</td>
                    <td>${row.success}</td>
                    <td>${row.declines}</td>
                    <td>${row.rate}%</td>
                </tr>
            `).join('');

            statsTable.style.display = 'table';
            document.getElementById('filters').style.display = 'flex';
        }

        if (Object.keys(processedData).length > 0) {
            updateFilters();
            updateStatsTable();
        } else {
            showError('No data available. Please visit the Import page to upload a CSV file.');
        }
    </script>
</body>
