<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Call Analytics Dashboard - Quay 1</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', 'Helvetica Neue', Arial, sans-serif;
            font-weight: 400;
            background: #F7FAFC;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            font-size: 2.5rem;
            color: #2D3748;
        }

        .nav-bar {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            background: #EDF2F7;
            padding: 10px 20px;
            border-radius: 8px;
        }

        .nav-bar a {
            padding: 10px 20px;
            border: 1px solid #E2E8F0;
            border-radius: 6px;
            background: white;
            color: #2D3748;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-bar a:hover {
            background: #4A5568;
            color: white;
            border-color: #4A5568;
        }

        .filters {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filters label {
            font-weight: 500;
            color: #2D3748;
        }

        select {
            padding: 10px 15px;
            border: 1px solid #E2E8F0;
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            color: #2D3748;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 400;
        }

        select:focus {
            outline: none;
            border-color: #4A5568;
            box-shadow: 0 0 0 3px rgba(74, 85, 104, 0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-item {
            background: white;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .stat-item:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2D3748;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 1rem;
            color: #718096;
        }

        .month-summary {
            margin-top: 30px;
        }

        .month-summary h3 {
            color: #2D3748;
            margin-bottom: 10px;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #E2E8F0;
        }

        th {
            background: #EDF2F7;
            color: #2D3748;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
        }

        td {
            color: #2D3748;
            font-family: 'Poppins', sans-serif;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            color: #2D3748;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
        }

        .download-btn {
            margin-top: 10px;
            padding: 10px 20px;
            border: 1px solid #E2E8F0;
            border-radius: 6px;
            background: white;
            color: #2D3748;
            cursor: pointer;
            width: 100%;
            text-align: center;
            font-weight: 500;
        }

        .download-btn:hover {
            background: #4A5568;
            color: white;
            border-color: #4A5568;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            color: #DC2626;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            border: 1px solid rgba(239, 68, 68, 0.3);
            font-weight: 500;
        }

        button#clearData {
            padding: 10px 20px;
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 6px;
            background: white;
            color: #DC2626;
            font-weight: 500;
            cursor: pointer;
        }

        button#clearData:hover {
            background: #DC2626;
            color: white;
            border-color: #DC2626;
        }

        button#viewReports {
            padding: 10px 20px;
            border: 1px solid #E2E8F0;
            border-radius: 6px;
            background: white;
            color: #2D3748;
            font-weight: 500;
            cursor: pointer;
        }

        button#viewReports:hover {
            background: #4A5568;
            color: white;
            border-color: #4A5568;
        }

        @media (max-width: 768px) {
            .filters {
                flex-direction: column;
                align-items: stretch;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .nav-bar {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .chart-wrapper {
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Quay 1 International Realty</h1>
        </div>
        
        <div class="nav-bar">
            <a href="index.html">Dashboard</a>
            <a href="stats.html">Stats</a>
            <a href="import.html">Import Data</a>
        </div>

        <button id="viewReports" style="display: none;"><i class="fas fa-chart-bar"></i> View Reports</button>
        <div class="error" id="errorMessage"></div>

        <div class="filters" id="filters" style="display: none;">
            <label>
                <strong>View Type:</strong>
                <select id="viewType">
                    <option value="individual">Individual Performance</option>
                    <option value="comparison">Caller Comparison</option>
                    <option value="trend">Monthly Trend</option>
                    <option value="stacked">Call Outcomes</option>
                </select>
            </label>
            <label>
                <strong>Metric:</strong>
                <select id="metricType">
                    <option value="calls">Total Calls</option>
                    <option value="success">Successful Calls</option>
                    <option value="declines">Declined Calls</option>
                    <option value="rate">Success Rate</option>
                </select>
            </label>
            <label>
                <strong>Month:</strong>
                <select id="monthFilter">
                    <option value="all">All Months</option>
                </select>
            </label>
            <label>
                <strong>Start Month:</strong>
                <select id="startMonth">
                    <option value="all">Any</option>
                </select>
            </label>
            <label>
                <strong>End Month:</strong>
                <select id="endMonth">
                    <option value="all">Any</option>
                </select>
            </label>
            <label>
                <strong>Caller:</strong>
                <select id="callerFilter">
                    <option value="all">All Callers</option>
                </select>
            </label>
            <button id="clearData"><i class="fas fa-trash-alt"></i> Clear Data</button>
        </div>

        <div class="stats-summary" id="statsSummary">
            <div class="stats-grid" id="statsGrid"></div>
            <div class="month-summary" id="monthSummary">
                <h3>Monthly Summary</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Month</th>
                            <th>Total Calls</th>
                            <th>Successful Calls</th>
                            <th>Declined Calls</th>
                            <th>Success Rate (%)</th>
                        </tr>
                    </thead>
                    <tbody id="monthSummaryTable"></tbody>
                </table>
            </div>
        </div>

        <div class="charts-grid" id="chartsContainer"></div>
    </div>

    <script>
        let processedData = JSON.parse(localStorage.getItem('callAnalyticsData')) || {};
        let charts = {};

        const viewReportsButton = document.getElementById('viewReports');
        const errorDiv = document.getElementById('errorMessage');
        const clearDataButton = document.getElementById('clearData');
        const viewTypeSelect = document.getElementById('viewType');
        const metricTypeSelect = document.getElementById('metricType');
        const monthFilterSelect = document.getElementById('monthFilter');
        const startMonthSelect = document.getElementById('startMonth');
        const endMonthSelect = document.getElementById('endMonth');
        const callerFilterSelect = document.getElementById('callerFilter');

        viewReportsButton.addEventListener('click', showReports);
        clearDataButton.addEventListener('click', clearStoredData);
        viewTypeSelect.addEventListener('change', () => { updateStats(); createCharts(); });
        metricTypeSelect.addEventListener('change', createCharts);
        monthFilterSelect.addEventListener('change', () => { updateStats(); createCharts(); });
        startMonthSelect.addEventListener('change', createCharts);
        endMonthSelect.addEventListener('change', createCharts);
        callerFilterSelect.addEventListener('change', () => { updateStats(); createCharts(); });

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function showReports() {
            if (Object.keys(processedData).length === 0) {
                showError('No data available. Please visit the Import page to upload a CSV file.');
                return;
            }

            viewReportsButton.style.display = 'none';
            document.getElementById('filters').style.display = 'flex';
            document.getElementById('statsSummary').style.display = 'block';
            updateFilters();
            updateStats();
            createCharts();
        }

        function clearStoredData() {
            if (confirm('Are you sure you want to clear all stored data? This cannot be undone.')) {
                processedData = {};
                localStorage.removeItem('callAnalyticsData');
                localStorage.removeItem('importedHashes');
                document.getElementById('filters').style.display = 'none';
                document.getElementById('statsSummary').style.display = 'none';
                document.getElementById('chartsContainer').innerHTML = '';
                document.getElementById('monthSummary').style.display = 'none';
                viewReportsButton.style.display = 'block';
                Object.values(charts).forEach(chart => chart.destroy());
                charts = {};
                showError('Stored data cleared. Visit Import page to upload a CSV file.');
            }
        }

        function updateFilters() {
            const allPeriods = new Set();
            const allCallers = new Set();
            Object.entries(processedData).forEach(([caller, periods]) => {
                allCallers.add(caller);
                Object.keys(periods).forEach(period => allPeriods.add(period));
            });
            const sortedPeriods = Array.from(allPeriods).sort((a, b) => {
                const dateA = a === 'Unknown' ? new Date(0) : new Date(a);
                const dateB = b === 'Unknown' ? new Date(0) : new Date(b);
                return dateA - dateB;
            });
            const sortedCallers = Array.from(allCallers).sort();

            monthFilterSelect.innerHTML = '<option value="all">All Months</option>';
            startMonthSelect.innerHTML = '<option value="all">Any</option>';
            endMonthSelect.innerHTML = '<option value="all">Any</option>';
            callerFilterSelect.innerHTML = '<option value="all">All Callers</option>';

            sortedPeriods.forEach(period => {
                const option = document.createElement('option');
                option.value = period;
                option.textContent = period;
                monthFilterSelect.appendChild(option);
                startMonthSelect.appendChild(option.cloneNode(true));
                endMonthSelect.appendChild(option.cloneNode(true));
            });

            sortedCallers.forEach(caller => {
                const option = document.createElement('option');
                option.value = caller;
                option.textContent = caller;
                callerFilterSelect.appendChild(option);
            });
        }

        function updateStats() {
            const statsGrid = document.getElementById('statsGrid');
            const monthSummaryTable = document.getElementById('monthSummaryTable');
            const callerFilter = callerFilterSelect.value;
            const selectedMonth = monthFilterSelect.value;

            let filteredData = processedData;
            if (callerFilter !== 'all') {
                filteredData = { [callerFilter]: processedData[callerFilter] || {} };
            }

            let monthFilteredData = {};
            Object.entries(filteredData).forEach(([caller, periods]) => {
                monthFilteredData[caller] = {};
                if (selectedMonth === 'all') {
                    monthFilteredData[caller] = periods;
                } else if (periods[selectedMonth]) {
                    monthFilteredData[caller][selectedMonth] = periods[selectedMonth];
                }
            });

            if (Object.keys(monthFilteredData).length === 0 || 
                Object.values(monthFilteredData).every(periods => Object.keys(periods).length === 0)) {
                statsGrid.innerHTML = `
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Top 1</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Top 2</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Top 3</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Total Callers</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Total Calls</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Successful</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Success Rate</div></div>
                `;
                monthSummaryTable.innerHTML = '';
                document.getElementById('monthSummary').style.display = 'none';
                return;
            }

            let totalCallers = 0;
            let totalCalls = 0, totalSuccess = 0, totalDeclines = 0;
            const monthTotals = {};

            Object.entries(monthFilteredData).forEach(([caller, periods]) => {
                if (Object.keys(periods).length > 0) {
                    totalCallers++;
                }
                Object.entries(periods).forEach(([period, stats]) => {
                    if (!monthTotals[period]) {
                        monthTotals[period] = { calls: 0, success: 0, declines: 0 };
                    }
                    monthTotals[period].calls += stats.calls;
                    monthTotals[period].success += stats.success;
                    monthTotals[period].declines += stats.declines;
                    totalCalls += stats.calls;
                    totalSuccess += stats.success;
                    totalDeclines += stats.declines;
                });
            });

            const successRate = totalCalls > 0 ? ((totalSuccess / totalCalls) * 100).toFixed(1) : 0;

            const topPerformers = [];
            const callerStats = {};
            let maxCalls = 0;
            Object.entries(monthFilteredData).forEach(([caller, periods]) => {
                let callerCalls = 0, callerSuccess = 0, totalCallsForCaller = 0;
                Object.values(periods).forEach(stats => {
                    callerCalls += stats.calls;
                    callerSuccess += stats.success;
                    totalCallsForCaller += stats.calls;
                });
                maxCalls = Math.max(maxCalls, callerCalls);
                const callerRate = totalCallsForCaller > 0 ? (callerSuccess / totalCallsForCaller * 100) : 0;
                callerStats[caller] = { calls: callerCalls, rate: callerRate };
                topPerformers.push({ caller, calls: callerCalls, rate: callerRate });
            });

            topPerformers.forEach(perf => {
                perf.normalizedScore = (perf.calls / (maxCalls > 0 ? maxCalls : 1) * 100 + perf.rate) / 2;
            });
            topPerformers.sort((a, b) => b.normalizedScore - a.normalizedScore).slice(0, 3);

            statsGrid.innerHTML = `
                <div class="stat-item" ${topPerformers[0] ? `onclick="callerFilterSelect.value='${topPerformers[0].caller}'; updateStats(); createCharts();"` : ''}>
                    <div class="stat-value">${topPerformers[0] ? topPerformers[0].caller : 'N/A'}</div>
                    <div class="stat-label">Top 1</div>
                </div>
                <div class="stat-item" ${topPerformers[1] ? `onclick="callerFilterSelect.value='${topPerformers[1].caller}'; updateStats(); createCharts();"` : ''}>
                    <div class="stat-value">${topPerformers[1] ? topPerformers[1].caller : 'N/A'}</div>
                    <div class="stat-label">Top 2</div>
                </div>
                <div class="stat-item" ${topPerformers[2] ? `onclick="callerFilterSelect.value='${topPerformers[2].caller}'; updateStats(); createCharts();"` : ''}>
                    <div class="stat-value">${topPerformers[2] ? topPerformers[2].caller : 'N/A'}</div>
                    <div class="stat-label">Top 3</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${totalCallers}</div>
                    <div class="stat-label">Total Callers</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${totalCalls.toLocaleString()}</div>
                    <div class="stat-label">Total Calls</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${totalSuccess.toLocaleString()}</div>
                    <div class="stat-label">Successful</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${successRate}%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
            `;

            const sortedPeriods = Object.keys(monthTotals).sort((a, b) => {
                const dateA = a === 'Unknown' ? new Date(0) : new Date(a);
                const dateB = b === 'Unknown' ? new Date(0) : new Date(b);
                return dateA - dateB;
            });

            monthSummaryTable.innerHTML = sortedPeriods.map(period => {
                const stats = monthTotals[period];
                const successRate = stats.calls > 0 ? ((stats.success / stats.calls) * 100).toFixed(1) : 0;
                return `
                    <tr>
                        <td>${period}</td>
                        <td>${stats.calls}</td>
                        <td>${stats.success}</td>
                        <td>${stats.declines}</td>
                        <td>${successRate}%</td>
                    </tr>
                `;
            }).join('');

            document.getElementById('monthSummary').style.display = sortedPeriods.length > 0 ? 'block' : 'none';
        }

        function createCharts() {
            const container = document.getElementById('chartsContainer');
            const viewType = viewTypeSelect.value;
            const metricType = metricTypeSelect.value;
            const selectedMonth = monthFilterSelect.value;
            const startMonth = startMonthSelect.value;
            const endMonth = endMonthSelect.value;
            const callerFilter = callerFilterSelect.value;

            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};
            container.innerHTML = '';

            const allPeriods = new Set();
            Object.values(processedData).forEach(periods => {
                Object.keys(periods).forEach(period => allPeriods.add(period));
            });
            let filteredPeriods = Array.from(allPeriods).sort((a, b) => {
                const dateA = a === 'Unknown' ? new Date(0) : new Date(a);
                const dateB = b === 'Unknown' ? new Date(0) : new Date(b);
                return dateA - dateB;
            });

            if (selectedMonth !== 'all') {
                filteredPeriods = filteredPeriods.filter(period => period === selectedMonth);
            } else if (startMonth !== 'all' || endMonth !== 'all') {
                const startDate = startMonth === 'all' ? new Date(0) : new Date(startMonth);
                const endDate = endMonth === 'all' ? new Date('9999-12-31') : new Date(endMonth);
                filteredPeriods = filteredPeriods.filter(period => {
                    const periodDate = period === 'Unknown' ? new Date(0) : new Date(period);
                    return periodDate >= startDate && periodDate <= endDate;
                });
            }

            let filteredData = processedData;
            if (callerFilter !== 'all') {
                filteredData = { [callerFilter]: processedData[callerFilter] || {} };
            }

            if (filteredPeriods.length === 0 || Object.keys(filteredData).length === 0) {
                showError('No data available for the selected filters.');
                return;
            }

            if (viewType === 'individual') {
                createIndividualCharts(metricType, filteredPeriods, filteredData);
            } else if (viewType === 'comparison') {
                createComparisonChart(metricType, filteredPeriods, filteredData);
            } else if (viewType === 'trend') {
                createTrendChart(metricType, filteredPeriods, filteredData);
            } else if (viewType === 'stacked') {
                createStackedChart(filteredPeriods, filteredData);
            }
        }

        function createIndividualCharts(metricType, filteredPeriods, filteredData) {
            const container = document.getElementById('chartsContainer');

            Object.entries(filteredData).forEach(([caller, periods]) => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                
                const canvas = document.createElement('canvas');
                const chartId = `chart-${caller.replace(/\s+/g, '-')}`;
                canvas.id = chartId;

                chartDiv.innerHTML = `
                    <div class="chart-title">${caller}</div>
                    <div class="chart-wrapper"></div>
                    <button class="download-btn" onclick="downloadChart('${chartId}', '${caller} - ${getMetricLabel(metricType)}')"><i class="fas fa-download"></i> Download</button>
                `;
                
                chartDiv.querySelector('.chart-wrapper').appendChild(canvas);
                container.appendChild(chartDiv);

                const data = filteredPeriods.map(period => {
                    const p = periods[period];
                    if (!p) return null;
                    switch(metricType) {
                        case 'calls': return p.calls;
                        case 'success': return p.success;
                        case 'declines': return p.declines;
                        case 'rate': return p.calls > 0 ? (p.success / p.calls * 100) : 0;
                        default: return p.calls;
                    }
                });

                const tooltipData = filteredPeriods.map(period => {
                    const p = periods[period] || { calls: 0, success: 0, declines: 0 };
                    return {
                        calls: p.calls,
                        success: p.success,
                        declines: p.declines,
                        rate: p.calls > 0 ? ((p.success / p.calls) * 100).toFixed(1) : 0
                    };
                });

                const ctx = canvas.getContext('2d');
                charts[chartId] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: filteredPeriods,
                        datasets: [{
                            label: getMetricLabel(metricType),
                            data: data,
                            borderColor: '#2D3748',
                            backgroundColor: 'rgba(45, 55, 72, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#4A5568',
                            pointBorderColor: '#2D3748',
                            pointBorderWidth: 2,
                            pointRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const index = context.dataIndex;
                                        const stats = tooltipData[index];
                                        return [
                                            `Total Calls: ${stats.calls}`,
                                            `Successful: ${stats.success}`,
                                            `Declined: ${stats.declines}`,
                                            `Success Rate: ${stats.rate}%`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: 'rgba(226, 232, 240, 0.3)' },
                                ticks: { color: '#2D3748', font: { family: 'Poppins' } }
                            },
                            x: {
                                grid: { color: 'rgba(226, 232, 240, 0.3)' },
                                ticks: { color: '#2D3748', font: { family: 'Poppins' } }
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const month = filteredPeriods[index];
                                monthFilterSelect.value = month;
                                updateStats();
                                createCharts();
                            }
                        }
                    }
                });
            });
        }

        function createComparisonChart(metricType, filteredPeriods, filteredData) {
            const container = document.getElementById('chartsContainer');
            
            const chartDiv = document.createElement('div');
            chartDiv.className = 'chart-container';
            chartDiv.style.gridColumn = '1 / -1';
            
            const canvas = document.createElement('canvas');
            const chartId = 'comparison-chart';
            canvas.id = chartId;

            chartDiv.innerHTML = `
                <div class="chart-title">All Callers Comparison - ${getMetricLabel(metricType)}</div>
                <div class="chart-wrapper"></div>
                <button class="download-btn" onclick="downloadChart('${chartId}', 'Comparison - ${getMetricLabel(metricType)}')"><i class="fas fa-download"></i> Download</button>
            `;
            
            chartDiv.querySelector('.chart-wrapper').appendChild(canvas);
            container.appendChild(chartDiv);

            const datasets = Object.entries(filteredData).map(([caller, periods], index) => {
                const colors = ['#2D3748', '#4A5568', '#718096', '#A0AEC0'];
                const color = colors[index % colors.length];
                
                const data = filteredPeriods.map(period => {
                    const p = periods[period];
                    if (!p) return null;
                    switch(metricType) {
                        case 'calls': return p.calls;
                        case 'success': return p.success;
                        case 'declines': return p.declines;
                        case 'rate': return p.calls > 0 ? (p.success / p.calls * 100) : 0;
                        default: return p.calls;
                    }
                });

                const tooltipData = filteredPeriods.map(period => {
                    const p = periods[period] || { calls: 0, success: 0, declines: 0 };
                    return {
                        calls: p.calls,
                        success: p.success,
                        declines: p.declines,
                        rate: p.calls > 0 ? ((p.success / p.calls) * 100).toFixed(1) : 0
                    };
                });

                return {
                    label: caller,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '20',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 5,
                    tooltipData: tooltipData
                };
            });

            const ctx = canvas.getContext('2d');
            charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: { labels: filteredPeriods, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top', labels: { usePointStyle: true, padding: 20, font: { family: 'Poppins' } } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const dataset = context.dataset;
                                    const stats = dataset.tooltipData[index];
                                    return [
                                        `${dataset.label}:`,
                                        `Total Calls: ${stats.calls}`,
                                        `Successful: ${stats.success}`,
                                        `Declined: ${stats.declines}`,
                                        `Success Rate: ${stats.rate}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, grid: { color: 'rgba(226, 232, 240, 0.3)' }, ticks: { color: '#2D3748', font: { family: 'Poppins' } } },
                        x: { grid: { color: 'rgba(226, 232, 240, 0.3)' }, ticks: { color: '#2D3748', font: { family: 'Poppins' } } }
                    },
                    interaction: { intersect: false, mode: 'index' },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const month = filteredPeriods[index];
                            monthFilterSelect.value = month;
                            updateStats();
                            createCharts();
                        }
                    }
                }
            });
        }

        function createTrendChart(metricType, filteredPeriods, filteredData) {
            const container = document.getElementById('chartsContainer');
            
            const chartDiv = document.createElement('div');
            chartDiv.className = 'chart-container';
            chartDiv.style.gridColumn = '1 / -1';
            
            const canvas = document.createElement('canvas');
            const chartId = 'trend-chart';
            canvas.id = chartId;

            chartDiv.innerHTML = `
                <div class="chart-title">Monthly Trend - ${getMetricLabel(metricType)}</div>
                <div class="chart-wrapper"></div>
                <button class="download-btn" onclick="downloadChart('${chartId}', 'Trend - ${getMetricLabel(metricType)}')"><i class="fas fa-download"></i> Download</button>
            `;
            
            chartDiv.querySelector('.chart-wrapper').appendChild(canvas);
            container.appendChild(chartDiv);

            const data = filteredPeriods.map(period => {
                let total = 0;
                let totalCalls = 0;
                Object.values(filteredData).forEach(callerData => {
                    const stats = callerData[period];
                    if (stats) {
                        switch(metricType) {
                            case 'calls': total += stats.calls; break;
                            case 'success': total += stats.success; break;
                            case 'declines': total += stats.declines; break;
                            case 'rate':
                                totalCalls += stats.calls;
                                total += stats.success;
                                break;
                        }
                    }
                });
                if (metricType === 'rate') {
                    return totalCalls > 0 ? (total / totalCalls * 100) : 0;
                }
                return total;
            });

            const tooltipData = filteredPeriods.map(period => {
                let calls = 0, success = 0, declines = 0;
                Object.values(filteredData).forEach(callerData => {
                    const stats = callerData[period];
                    if (stats) {
                        calls += stats.calls;
                        success += stats.success;
                        declines += stats.declines;
                    }
                });
                return {
                    calls: calls,
                    success: success,
                    declines: declines,
                    rate: calls > 0 ? ((success / calls) * 100).toFixed(1) : 0
                };
            });

            const ctx = canvas.getContext('2d');
            charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: filteredPeriods,
                    datasets: [{
                        label: getMetricLabel(metricType),
                        data: data,
                        borderColor: '#2D3748',
                        backgroundColor: 'rgba(45, 55, 72, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: '#4A5568',
                        pointBorderColor: '#2D3748',
                        pointBorderWidth: 2,
                        pointRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const stats = tooltipData[index];
                                    return [
                                        `Total Calls: ${stats.calls}`,
                                        `Successful: ${stats.success}`,
                                        `Declined: ${stats.declines}`,
                                        `Success Rate: ${stats.rate}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, grid: { color: 'rgba(226, 232, 240, 0.3)' }, ticks: { color: '#2D3748', font: { family: 'Poppins' } } },
                        x: { grid: { color: 'rgba(226, 232, 240, 0.3)' }, ticks: { color: '#2D3748', font: { family: 'Poppins' } } }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const month = filteredPeriods[index];
                            monthFilterSelect.value = month;
                            updateStats();
                            createCharts();
                        }
                    }
                }
            });
        }

        function createStackedChart(filteredPeriods, filteredData) {
            const container = document.getElementById('chartsContainer');
            
            const chartDiv = document.createElement('div');
            chartDiv.className = 'chart-container';
            chartDiv.style.gridColumn = '1 / -1';
            
            const canvas = document.createElement('canvas');
            const chartId = 'stacked-chart';
            canvas.id = chartId;

            chartDiv.innerHTML = `
                <div class="chart-title">Call Outcomes by Caller</div>
                <div class="chart-wrapper"></div>
                <button class="download-btn" onclick="downloadChart('${chartId}', 'Call Outcomes by Caller')"><i class="fas fa-download"></i> Download</button>
            `;
            
            chartDiv.querySelector('.chart-wrapper').appendChild(canvas);
            container.appendChild(chartDiv);

            const datasets = [
                {
                    label: 'Successful Calls',
                    data: filteredPeriods.map(period => {
                        let total = 0;
                        Object.values(filteredData).forEach(callerData => {
                            const stats = callerData[period];
                            if (stats) total += stats.success;
                        });
                        return total;
                    }),
                    backgroundColor: '#4A5568',
                    borderColor: '#4A5568',
                    borderWidth: 1
                },
                {
                    label: 'Declined Calls',
                    data: filteredPeriods.map(period => {
                        let total = 0;
                        Object.values(filteredData).forEach(callerData => {
                            const stats = callerData[period];
                            if (stats) total += stats.declines;
                        });
                        return total;
                    }),
                    backgroundColor: '#DC2626',
                    borderColor: '#DC2626',
                    borderWidth: 1
                }
            ];

            const tooltipData = filteredPeriods.map(period => {
                let calls = 0, success = 0, declines = 0;
                Object.values(filteredData).forEach(callerData => {
                    const stats = callerData[period];
                    if (stats) {
                        calls += stats.calls;
                        success += stats.success;
                        declines += stats.declines;
                    }
                });
                return {
                    calls: calls,
                    success: success,
                    declines: declines,
                    rate: calls > 0 ? ((success / calls) * 100).toFixed(1) : 0
                };
            });

            const ctx = canvas.getContext('2d');
            charts[chartId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: filteredPeriods,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top', labels: { usePointStyle: true, padding: 20, font: { family: 'Poppins' } } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const stats = tooltipData[index];
                                    return [
                                        `${context.dataset.label}: ${context.raw}`,
                                        `Total Calls: ${stats.calls}`,
                                        `Successful: ${stats.success}`,
                                        `Declined: ${stats.declines}`,
                                        `Success Rate: ${stats.rate}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            grid: { color: 'rgba(226, 232, 240, 0.3)' },
                            ticks: { color: '#2D3748', font: { family: 'Poppins' } }
                        },
                        x: {
                            stacked: true,
                            grid: { color: 'rgba(226, 232, 240, 0.3)' },
                            ticks: { color: '#2D3748', font: { family: 'Poppins' } }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const month = filteredPeriods[index];
                            monthFilterSelect.value = month;
                            updateStats();
                            createCharts();
                        }
                    }
                }
            });
        }

        function getMetricLabel(metricType) {
            switch(metricType) {
                case 'calls': return 'Total Calls';
                case 'success': return 'Successful Calls';
                case 'declines': return 'Declined Calls';
                case 'rate': return 'Success Rate (%)';
                default: return 'Total Calls';
            }
        }

        function downloadChart(chartId, title) {
            const canvas = document.getElementById(chartId);
            html2canvas(canvas).then(canvas => {
                const link = document.createElement('a');
                link.download = `${title}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }

        if (Object.keys(processedData).length > 0) {
            showReports();
        } else {
            viewReportsButton.style.display = 'block';
            document.getElementById('statsSummary').style.display = 'none';
            showError('No data available. Please visit the Import page to upload a CSV file.');
        }
    </script>
</body>
</html>
