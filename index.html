<body>
    <div class="container">
        <div class="header">
            <h1>Quay 1 International Realty</h1>
        </div>
        
        <div class="nav-bar">
            <a href="index.html">Dashboard</a>
            <a href="stats.html">Stats</a>
            <a href="import.html">Import Data</a>
            <button id="refreshButton" style="padding: 10px 20px; border: 2px solid #98C5ED; border-radius: 10px; background: white; color: #3D5BA6; font-weight: 500; cursor: pointer;"><i class="fas fa-sync-alt"></i> Refresh Data</button>
        </div>

        <!-- Modal for entering credentials -->
        <div id="refreshModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center;">
            <div style="background: white; padding: 20px; border-radius: 10px; max-width: 400px; width: 90%;">
                <h3 style="color: #3D5BA6; margin-bottom: 15px;">Enter Dialfire Credentials</h3>
                <input type="text" id="campaignIdInput" placeholder="Campaign ID (e.g., N4UMU8GPQKZMRM93)" style="width: 100%; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #98C5ED;">
                <input type="text" id="campaignTokenInput" placeholder="Campaign Token" style="width: 100%; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #98C5ED;">
                <button id="submitRefresh" style="padding: 10px 20px; background: #3D5BA6; color: white; border: none; border-radius: 10px; cursor: pointer;">Fetch</button>
                <button id="cancelRefresh" style="padding: 10px 20px; background: #D20A03; color: white; border: none; border-radius: 10px; margin-left: 10px;">Cancel</button>
            </div>
        </div>

        <button id="viewReports" style="display: none;"><i class="fas fa-chart-bar"></i> View Reports</button>
        <div class="error" id="errorMessage"></div>
        <div class="loading" id="loading"><i class="fas fa-spinner fa-spin"></i> Fetching from Dialfire...</div>

        <div class="filters" id="filters" style="display: none;">
            <!-- ... rest of filters unchanged ... -->
        </div>

        <div class="stats-summary" id="statsSummary">
            <div class="stats-grid" id="statsGrid"></div>
            <div class="month-summary" id="monthSummary">
                <h3 style="color: #3D5BA6; margin-bottom: 10px; font-family: 'Gotham', sans-serif;">Monthly Summary</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Month</th>
                            <th>Total Calls</th>
                            <th>Successful Calls</th>
                            <th>Declined Calls</th>
                            <th>Success Rate (%)</th>
                        </tr>
                    </thead>
                    <tbody id="monthSummaryTable"></tbody>
                </table>
            </div>
        </div>

        <div class="charts-grid" id="chartsContainer"></div>
    </div>

    <script>
        let processedData = JSON.parse(localStorage.getItem('callAnalyticsData')) || {};
        let importedHashes = new Set(JSON.parse(localStorage.getItem('importedHashes')) || []);
        let charts = {};

        const viewReportsButton = document.getElementById('viewReports');
        const errorDiv = document.getElementById('errorMessage');
        const loading = document.getElementById('loading');
        const clearDataButton = document.getElementById('clearData');
        const viewTypeSelect = document.getElementById('viewType');
        const metricTypeSelect = document.getElementById('metricType');
        const monthFilterSelect = document.getElementById('monthFilter');
        const startMonthSelect = document.getElementById('startMonth');
        const endMonthSelect = document.getElementById('endMonth');
        const callerFilterSelect = document.getElementById('callerFilter');
        const refreshButton = document.getElementById('refreshButton');
        const refreshModal = document.getElementById('refreshModal');
        const campaignIdInput = document.getElementById('campaignIdInput');
        const campaignTokenInput = document.getElementById('campaignTokenInput');
        const submitRefresh = document.getElementById('submitRefresh');
        const cancelRefresh = document.getElementById('cancelRefresh');

        viewReportsButton.addEventListener('click', showReports);
        clearDataButton.addEventListener('click', clearStoredData);
        viewTypeSelect.addEventListener('change', () => { updateStats(); createCharts(); });
        metricTypeSelect.addEventListener('change', createCharts);
        monthFilterSelect.addEventListener('change', () => { updateStats(); createCharts(); });
        startMonthSelect.addEventListener('change', createCharts);
        endMonthSelect.addEventListener('change', createCharts);
        callerFilterSelect.addEventListener('change', () => { updateStats(); createCharts(); });
        refreshButton.addEventListener('click', () => { refreshModal.style.display = 'flex'; });
        cancelRefresh.addEventListener('click', () => { refreshModal.style.display = 'none'; });
        submitRefresh.addEventListener('click', fetchDialfireData);

        async function fetchDialfireData() {
            const campaignId = campaignIdInput.value.trim();
            const token = campaignTokenInput.value.trim();

            if (!campaignId || !token) {
                showError('Please enter campaign ID and token.');
                refreshModal.style.display = 'none';
                return;
            }

            showLoading(true);
            hideError();
            refreshModal.style.display = 'none';

            try {
                const baseUrl = 'https://app.dialfire.com'; // Update if tenant-specific (e.g., 'https://3f88c548.app.dialfire.com')
                let allData = [];
                let page = 1;
                let hasMore = true;

                while (hasMore) {
                    const url = `${baseUrl}/api/campaigns/${campaignId}/connections?page=${page}&per_page=100&since=2025-10-01`; // Added since for recent data
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API error ${response.status}: ${errorText}`);
                    }

                    const data = await response.json();
                    const items = data.items || data;
                    allData = allData.concat(items);
                    hasMore = items.length === 100;
                    page++;
                    if (page > 10) break; // Safety limit
                }

                console.log('Fetched connections:', allData); // Inspect in DevTools
                processData(allData);
                showLoading(false);
            } catch (error) {
                console.error('Fetch error:', error);
                showError(`Failed to fetch: ${error.message}. Check ID/token.`);
                showLoading(false);
            }
        }

        function generateHash(str, date) {
            let hash = 0;
            const combined = `${str}${date || ''}`;
            for (let i = 0; i < combined.length; i++) {
                hash = ((hash << 5) - hash) + combined.charCodeAt(i);
                hash |= 0;
            }
            return hash.toString();
        }

        function processData(apiData) {
            if (!apiData || apiData.length === 0) {
                showError('No connections found. Check campaign ID or date range.');
                return;
            }

            let totalProcessed = 0;
            let errorCount = 0;
            let duplicatesSkipped = 0;

            apiData.forEach((row, index) => {
                let callNotes = (row.comment || row.agent_notes || row.status_detail || '').toString();
                if (row.status_detail && !callNotes.includes(row.status_detail)) {
                    callNotes += ` Dialfire call result: ${row.status_detail}/$none`;
                }
                const activityDate = row.created_at || row.connected_at || row.updated_at;
                const activityDateStr = activityDate ? new Date(activityDate).toISOString().split('T')[0] : '';

                if (!callNotes) {
                    console.warn(`Row ${index + 1}: Empty notes, skipping.`);
                    return;
                }

                const rowHash = generateHash(callNotes, activityDateStr);
                if (importedHashes.has(rowHash)) {
                    console.log(`Row ${index + 1}: Duplicate, skipping.`);
                    duplicatesSkipped++;
                    return;
                }

                try {
                    let caller = '';
                    const callerMatch = callNotes.match(/Call user:\s*([^@]+)@clienthub/i);
                    if (callerMatch) {
                        caller = callerMatch[1].trim();
                    } else if (row.agent_name || row.user_name) {
                        caller = (row.agent_name || row.user_name).trim();
                        console.log(`Row ${index + 1}: Fallback caller: ${caller}`);
                    } else {
                        console.warn(`Row ${index + 1}: No caller in ${callNotes}`);
                        return;
                    }

                    const statusDetail = (row.status_detail || '').toLowerCase();
                    let result = null;
                    if (['success', 'connected', 'completed', 'sale_made', 'appointment_set'].some(s => statusDetail.includes(s))) {
                        result = 'success';
                    } else if (['declined', 'refused', 'no_interest', 'busy', 'no_answer'].some(s => statusDetail.includes(s))) {
                        result = 'declined';
                    }
                    const notesMatch = callNotes.match(/Dialfire call result:\s*(success|declined)\/\$none/i);
                    if (notesMatch && !result) {
                        result = notesMatch[1].toLowerCase();
                    }

                    if (!processedData[caller]) {
                        processedData[caller] = {};
                    }

                    const period = activityDateStr || 'Unknown';
                    if (!processedData[caller][period]) {
                        processedData[caller][period] = {
                            calls: 0,
                            success: 0,
                            declines: 0
                        };
                    }

                    processedData[caller][period].calls += 1;
                    if (result === 'success') {
                        processedData[caller][period].success += 1;
                    } else if (result === 'declined') {
                        processedData[caller][period].declines += 1;
                    }

                    importedHashes.add(rowHash);
                    totalProcessed++;
                } catch (error) {
                    errorCount++;
                    console.warn(`Error processing row ${index + 1}:`, error);
                }
            });

            localStorage.setItem('callAnalyticsData', JSON.stringify(processedData));
            localStorage.setItem('importedHashes', JSON.stringify(Array.from(importedHashes)));

            console.log('Processed:', { totalProcessed, errorCount, duplicatesSkipped, sampleData: processedData });

            if (totalProcessed === 0) {
                showError(`No new data. Errors: ${errorCount}, Duplicates: ${duplicatesSkipped}. Check console.`);
                return;
            }

            showReports();
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function showLoading(show) {
            loading.style.display = show ? 'block' : 'none';
        }

        function hideError() {
            errorDiv.style.display = 'none';
        }

        function showReports() {
            if (Object.keys(processedData).length === 0) {
                showError('No data available. Please visit the Import page or use Refresh Data.');
                return;
            }

            viewReportsButton.style.display = 'none';
            document.getElementById('filters').style.display = 'flex';
            document.getElementById('statsSummary').style.display = 'block';
            updateFilters();
            updateStats();
            createCharts();
        }

        function clearStoredData() {
            if (confirm('Are you sure you want to clear all stored data? This cannot be undone.')) {
                processedData = {};
                localStorage.removeItem('callAnalyticsData');
                localStorage.removeItem('importedHashes');
                document.getElementById('filters').style.display = 'none';
                document.getElementById('statsSummary').style.display = 'none';
                document.getElementById('chartsContainer').innerHTML = '';
                document.getElementById('monthSummary').style.display = 'none';
                viewReportsButton.style.display = 'none';
                Object.values(charts).forEach(chart => chart.destroy());
                charts = {};
                showError('Stored data cleared. Visit Import page or use Refresh Data.');
            }
        }

        function updateFilters() {
            const allPeriods = new Set();
            const allCallers = new Set();
            Object.entries(processedData).forEach(([caller, periods]) => {
                allCallers.add(caller);
                Object.keys(periods).forEach(period => allPeriods.add(period));
            });
            const sortedPeriods = Array.from(allPeriods).sort((a, b) => {
                const dateA = a === 'Unknown' ? new Date(0) : new Date(a);
                const dateB = b === 'Unknown' ? new Date(0) : new Date(b);
                return dateA - dateB;
            });
            const sortedCallers = Array.from(allCallers).sort();

            monthFilterSelect.innerHTML = '<option value="all">All Months</option>';
            startMonthSelect.innerHTML = '<option value="all">Any</option>';
            endMonthSelect.innerHTML = '<option value="all">Any</option>';
            callerFilterSelect.innerHTML = '<option value="all">All Callers</option>';

            sortedPeriods.forEach(period => {
                const option = document.createElement('option');
                option.value = period;
                option.textContent = period;
                monthFilterSelect.appendChild(option);
                startMonthSelect.appendChild(option.cloneNode(true));
                endMonthSelect.appendChild(option.cloneNode(true));
            });

            sortedCallers.forEach(caller => {
                const option = document.createElement('option');
                option.value = caller;
                option.textContent = caller;
                callerFilterSelect.appendChild(option);
            });
        }

        function updateStats() {
            const statsGrid = document.getElementById('statsGrid');
            const monthSummaryTable = document.getElementById('monthSummaryTable');
            const callerFilter = callerFilterSelect.value;
            const selectedMonth = monthFilterSelect.value;

            let filteredData = processedData;
            if (callerFilter !== 'all') {
                filteredData = { [callerFilter]: processedData[callerFilter] || {} };
            }

            let monthFilteredData = {};
            Object.entries(filteredData).forEach(([caller, periods]) => {
                monthFilteredData[caller] = {};
                if (selectedMonth === 'all') {
                    monthFilteredData[caller] = periods;
                } else if (periods[selectedMonth]) {
                    monthFilteredData[caller][selectedMonth] = periods[selectedMonth];
                }
            });

            if (Object.keys(monthFilteredData).length === 0 || 
                Object.values(monthFilteredData).every(periods => Object.keys(periods).length === 0)) {
                statsGrid.innerHTML = `
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Top 1</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Top 2</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Top 3</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Total Callers</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Total Calls</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Successful</div></div>
                    <div class="stat-item"><div class="stat-value">N/A</div><div class="stat-label">Success Rate</div></div>
                `;
                monthSummaryTable.innerHTML = '';
                document.getElementById('monthSummary').style.display = 'none';
                return;
            }

            let totalCallers = 0;
            let totalCalls = 0, totalSuccess = 0, totalDeclines = 0;
            const monthTotals = {};

            Object.entries(monthFilteredData).forEach(([caller, periods]) => {
                if (Object.keys(periods).length > 0) {
                    totalCallers++;
                }
                Object.entries(periods).forEach(([period, stats]) => {
                    if (!monthTotals[period]) {
                        monthTotals[period] = { calls: 0, success: 0, declines: 0 };
                    }
                    monthTotals[period].calls += stats.calls;
                    monthTotals[period].success += stats.success;
                    monthTotals[period].declines += stats.declines;
                    totalCalls += stats.calls;
                    totalSuccess += stats.success;
                    totalDeclines += stats.declines;
                });
            });

            const successRate = totalCalls > 0 ? ((totalSuccess / totalCalls) * 100).toFixed(1) : 0;

            const topPerformers = [];
            const callerStats = {};
            let maxCalls = 0;
            Object.entries(monthFilteredData).forEach(([caller, periods]) => {
                let callerCalls = 0, callerSuccess = 0, totalCallsForCaller = 0;
                Object.values(periods).forEach(stats => {
                    callerCalls += stats.calls;
                    callerSuccess += stats.success;
                    totalCallsForCaller += stats.calls;
                });
                maxCalls = Math.max(maxCalls, callerCalls);
                const callerRate = totalCallsForCaller > 0 ? (callerSuccess / totalCallsForCaller * 100) : 0;
                callerStats[caller] = { calls: callerCalls, rate: callerRate };
                topPerformers.push({ caller, calls: callerCalls, rate: callerRate });
            });

            topPerformers.forEach(perf => {
                perf.normalizedScore = (perf.calls / (maxCalls > 0 ? maxCalls : 1) * 100 + perf.rate) / 2;
            });
            topPerformers.sort((a, b) => b.normalizedScore - a.normalizedScore).slice(0, 3);

            statsGrid.innerHTML = `
                <div class="stat-item" ${topPerformers[0] ? `onclick="callerFilterSelect.value='${topPerformers[0].caller}'; updateStats(); createCharts();"` : ''}>
                    <div class="stat-value">${topPerformers[0] ? topPerformers[0].caller : 'N/A'}</div>
                    <div class="stat-label">Top 1</div>
                </div>
                <div class="stat-item" ${topPerformers[1] ? `onclick="callerFilterSelect.value='${topPerformers[1].caller}'; updateStats(); createCharts();"` : ''}>
                    <div class="stat-value">${topPerformers[1] ? topPerformers[1].caller : 'N/A'}</div>
                    <div class="stat-label">Top 2</div>
                </div>
                <div class="stat-item" ${topPerformers[2] ? `onclick="callerFilterSelect.value='${topPerformers[2].caller}'; updateStats(); createCharts();"` : ''}>
                    <div class="stat-value">${topPerformers[2] ? topPerformers[2].caller : 'N/A'}</div>
                    <div class="stat-label">Top 3</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${totalCallers}</div>
                    <div class="stat-label">Total Callers</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${totalCalls.toLocaleString()}</div>
                    <div class="stat-label">Total Calls</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${totalSuccess.toLocaleString()}</div>
                    <div class="stat-label">Successful</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${successRate}%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
            `;

            const sortedPeriods = Object.keys(monthTotals).sort((a, b) => {
                const dateA = a === 'Unknown' ? new Date(0) : new Date(a);
                const dateB = b === 'Unknown' ? new Date(0) : new Date(b);
                return dateA - dateB;
            });

            monthSummaryTable.innerHTML = sortedPeriods.map(period => {
                const stats = monthTotals[period];
                const successRate = stats.calls > 0 ? ((stats.success / stats.calls) * 100).toFixed(1) : 0;
                return `
                    <tr>
                        <td>${period}</td>
                        <td>${stats.calls}</td>
                        <td>${stats.success}</td>
                        <td>${stats.declines}</td>
                        <td>${successRate}%</td>
                    </tr>
                `;
            }).join('');

            document.getElementById('monthSummary').style.display = sortedPeriods.length > 0 ? 'block' : 'none';
        }

        function createCharts() {
            const container = document.getElementById('chartsContainer');
            const viewType = viewTypeSelect.value;
            const metricType = metricTypeSelect.value;
            const selectedMonth = monthFilterSelect.value;
            const startMonth = startMonthSelect.value;
            const endMonth = endMonthSelect.value;
            const callerFilter = callerFilterSelect.value;

            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};
            container.innerHTML = '';

            const allPeriods = new Set();
            Object.values(processedData).forEach(periods => {
                Object.keys(periods).forEach(period => allPeriods.add(period));
            });
            let filteredPeriods = Array.from(allPeriods).sort((a, b) => {
                const dateA = a === 'Unknown' ? new Date(0) : new Date(a);
                const dateB = b === 'Unknown' ? new Date(0) : new Date(b);
                return dateA - dateB;
            });

            if (selectedMonth !== 'all') {
                filteredPeriods = filteredPeriods.filter(period => period === selectedMonth);
            } else if (startMonth !== 'all' || endMonth !== 'all') {
                const startDate = startMonth === 'all' ? new Date(0) : new Date(startMonth);
                const endDate = endMonth === 'all' ? new Date('9999-12-31') : new Date(endMonth);
                filteredPeriods = filteredPeriods.filter(period => {
                    const periodDate = period === 'Unknown' ? new Date(0) : new Date(period);
                    return periodDate >= startDate && periodDate <= endDate;
                });
            }

            let filteredData = processedData;
            if (callerFilter !== 'all') {
                filteredData = { [callerFilter]: processedData[callerFilter] || {} };
            }

            if (filteredPeriods.length === 0 || Object.keys(filteredData).length === 0) {
                showError('No data available for the selected filters.');
                return;
            }

            if (viewType === 'individual') {
                createIndividualCharts(metricType, filteredPeriods, filteredData);
            } else if (viewType === 'comparison') {
                createComparisonChart(metricType, filteredPeriods, filteredData);
            } else if (viewType === 'trend') {
                createTrendChart(metricType, filteredPeriods, filteredData);
            } else if (viewType === 'stacked') {
                createStackedChart(filteredPeriods, filteredData);
            }
        }

        function createIndividualCharts(metricType, filteredPeriods, filteredData) {
            const container = document.getElementById('chartsContainer');

            Object.entries(filteredData).forEach(([caller, periods]) => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                
                const canvas = document.createElement('canvas');
                const chartId = `chart-${caller.replace(/\s+/g, '-')}`;
                canvas.id = chartId;

                chartDiv.innerHTML = `
                    <div class="chart-title">${caller}</div>
                    <div class="chart-wrapper"></div>
                    <button class="download-btn" onclick="downloadChart('${chartId}', '${caller} - ${getMetricLabel(metricType)}')"><i class="fas fa-download"></i> Download</button>
                `;
                
                chartDiv.querySelector('.chart-wrapper').appendChild(canvas);
                container.appendChild(chartDiv);

                const data = filteredPeriods.map(period => {
                    const p = periods[period];
                    if (!p) return null;
                    switch(metricType) {
                        case 'calls': return p.calls;
                        case 'success': return p.success;
                        case 'declines': return p.declines;
                        case 'rate': return p.calls > 0 ? (p.success / p.calls * 100) : 0;
                        default: return p.calls;
                    }
                });

                const tooltipData = filteredPeriods.map(period => {
                    const p = periods[period] || { calls: 0, success: 0, declines: 0 };
                    return {
                        calls: p.calls,
                        success: p.success,
                        declines: p.declines,
                        rate: p.calls > 0 ? ((p.success / p.calls) * 100).toFixed(1) : 0
                    };
                });

                const ctx = canvas.getContext('2d');
                charts[chartId] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: filteredPeriods,
                        datasets: [{
                            label: getMetricLabel(metricType),
                            data: data,
                            borderColor: '#3D5BA6',
                            backgroundColor: 'rgba(61, 91, 166, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#FDC503',
                            pointBorderColor: '#3D5BA6',
                            pointBorderWidth: 2,
                            pointRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const index = context.dataIndex;
                                        const stats = tooltipData[index];
                                        return [
                                            `Total Calls: ${stats.calls}`,
                                            `Successful: ${stats.success}`,
                                            `Declined: ${stats.declines}`,
                                            `Success Rate: ${stats.rate}%`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: 'rgba(152, 197, 237, 0.3)' },
                                ticks: { color: '#3D5BA6', font: { family: 'Gotham' } }
                            },
                            x: {
                                grid: { color: 'rgba(152, 197, 237, 0.3)' },
                                ticks: { color: '#3D5BA6', font: { family: 'Gotham' } }
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const month = filteredPeriods[index];
                                monthFilterSelect.value = month;
                                updateStats();
                                createCharts();
                            }
                        }
                    }
                });
            });
        }

        function createComparisonChart(metricType, filteredPeriods, filteredData) {
            const container = document.getElementById('chartsContainer');
            
            const chartDiv = document.createElement('div');
            chartDiv.className = 'chart-container';
            chartDiv.style.gridColumn = '1 / -1';
            
            const canvas = document.createElement('canvas');
            const chartId = 'comparison-chart';
            canvas.id = chartId;

            chartDiv.innerHTML = `
                <div class="chart-title">All Callers Comparison - ${getMetricLabel(metricType)}</div>
                <div class="chart-wrapper"></div>
                <button class="download-btn" onclick="downloadChart('${chartId}', 'Comparison - ${getMetricLabel(metricType)}')"><i class="fas fa-download"></i> Download</button>
            `;
            
            chartDiv.querySelector('.chart-wrapper').appendChild(canvas);
            container.appendChild(chartDiv);

            const datasets = Object.entries(filteredData).map(([caller, periods], index) => {
                const colors = ['#3D5BA6', '#FDC503', '#98C5ED', '#D20A03'];
                const color = colors[index % colors.length];
                
                const data = filteredPeriods.map(period => {
                    const p = periods[period];
                    if (!p) return null;
                    switch(metricType) {
                        case 'calls': return p.calls;
                        case 'success': return p.success;
                        case 'declines': return p.declines;
                        case 'rate': return p.calls > 0 ? (p.success / p.calls * 100) : 0;
                        default: return p.calls;
                    }
                });

                const tooltipData = filteredPeriods.map(period => {
                    const p = periods[period] || { calls: 0, success: 0, declines: 0 };
                    return {
                        calls: p.calls,
                        success: p.success,
                        declines: p.declines,
                        rate: p.calls > 0 ? ((p.success / p.calls) * 100).toFixed(1) : 0
                    };
                });

                return {
                    label: caller,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '20',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 5,
                    tooltipData: tooltipData
                };
            });

            const ctx = canvas.getContext('2d');
            charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: { labels: filteredPeriods, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top', labels: { usePointStyle: true, padding: 20, font: { family: 'Gotham' } } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const dataset = context.dataset;
                                    const stats = dataset.tooltipData[index];
                                    return [
                                        `${dataset.label}:`,
                                        `Total Calls: ${stats.calls}`,
                                        `Successful: ${stats.success}`,
                                        `Declined: ${stats.declines}`,
                                        `Success Rate: ${stats.rate}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, grid: { color: 'rgba(152, 197, 237, 0.3)' }, ticks: { color: '#3D5BA6', font: { family: 'Gotham' } } },
                        x: { grid: { color: 'rgba(152, 197, 237, 0.3)' }, ticks: { color: '#3D5BA6', font: { family: 'Gotham' } } }
                    },
                    interaction: { intersect: false, mode: 'index' },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const month = filteredPeriods[index];
                            monthFilterSelect.value = month;
                            updateStats();
                            createCharts
